\documentclass[a4paper,12pt]{report}

\input{header.tex}


\title{Отчёт по курсовому проекту}
\author{(Бородин Дмитрий Сергеевич, Федоров Павел Вячеславович)}

\begin{document}

\maketitle

\tableofcontents

\addcontentsline{toc}{chapter}{Введение}
\chapter*{Введение}

\section*{Сервер}

\section*{Клиент}

\subsection*{Задание. 26}
Используется вызов pselect и рабочие потоки. Журналирование в отдельном потоки. Не обязательно пытаться отправлять все сообщения для одного MX за одну сессию.
\subsection*{Цели и задачи}
Цель: 
    Разработать \textbf{SMTP-клиент} с использованием рабочих потоков и pselect.

Задачи:
\begin{itemize}
    \item Проанализировать архитектурное решение maildir
    \item Разработать подход для обработки писем в maildir 
    \item Рассмотреть \textbf{SMTP}-протокол
    \item Проанализировать способы получения и обработки \textbf{MX}-записей
    \item Реализовать программу для отправки писем по протоколу \textbf{SMTP}
\end{itemize}


% Два предложения о содержании отчёта. Для нового абзаца в исходном тексте должна быть пустая строка.

% Это~-- шаблон отчёта (вот как оформляется длинное тире, перед котрым идёт неразрывный пробел).


% Здесь должно быть вербальное задание.

% А вот так оформляются списки:
% \begin{itemize}
% \item элемент списка;
% \item последний элемент списка.
% \end{itemize}

% Нумерованный список выглядит следующим образом.
% \begin{enumerate}
% \item Первый элемент.
% \item Второй элемент.
% \end{enumerate}

% \chapter{Аналитический раздел}

% \section{Сервер}

% \section{Клиент}

% \subsection{Алгоритм}

\chapter{Конструкторский раздел}

\section{Сервер}

\subsection{Конечный автомат состояний сервера}

Рис.~\ref{fig:fsm} нагенерил самодельный \textit{fsm2dot} из \textit{autogen} и \textit{dot2tex} на пару \textit{dot}. Никто не мешает изменить параметры типа \textit{rankdir} прямо в \textit{fsm2dot}, если он будет лучше смотреться, например, сверху-вниз.

\begin{figure}
\centering
\includegraphics[height=\textheight]{static/ClientDiagram_Final.jpg}
\caption{Состояния сервера}
\label{fig:fsm}
\end{figure}

\section{Клиент}

\subsection{Принцип действия}
Работу клиента можно разделить на 2 отдельные сущности: работа основного потока, работа рабочих потоков \textit{(далее воркеры)}
В основном потоке решено производить следующие действия
\begin{enumerate}
    \item Создание при инициализации и удаление при завершении списка воркеров
    \item Циклический поиск новых писем
    \item Распределение писем по воркерам
    \item Перехват сигналов на завершение работы
\end{enumerate}

При запуске сервера, главный поток создает пул воркереров и помещает в него логгер и рабочие потоки. Количество рабочих потоков напрямую зависит от количества процессоров на устройстве. Однако, для устройств в которых процессоров меньше чем 3 создается обязательно 1 рабочих процесс
Для \textit{Изящного завершения} необходимо подписаться на перехват сигналов. Для более корректного и однозначного управления потоками программы необходимо, чтобы рабочие потоки не перехватывали общие сигналы с главным потоком. Для этого решено использовать 2 сигнала \textbf{SIGINT} для завершения программы ~-- перехватывается главным потоком и \textbf{SIGUSR1} для управления воркерами. Во время корректного завершения главный поток оповещает всех воркеров по очереди в своем спике с помощью сигнала и ожидает их завершения. После завершения необходимо удалить данные воркера и освободить все ресурсы занимаемые главным потоком.

Рабочие процессы в данном случае выполняют роль связных. Их деятельность можно описать следующими действиями:
\begin{enumerate}
    \item Контролирует список соединений
    \item Получает и обрабатывает задания от главного потока
    \item Отправляет письма
\end{enumerate}

Воркер во время инициализации получает служебную информацию для поддержания связи с главным потоком. Так как в требованиях к заданию указывается, что соединение должно быть неблокируемым, каждый воркер обладает множествами пишущих, читающих и обработчиков прерываний. Помимо указаных множеств в данном блоке информации хранится список активных соединений (сокетов)
Во время работы воркер ожидает на \textbf{pselect} готовых к работе соединений. Однако, перед этим необходимо распределить новые задания от главного потока. После обработки всех заданий воркер для каждого готового соединения передает управление SMTP контроллеру до тех пор, пока:
\begin{itemize}
    \item Текущее состояние соединения - в процессе
    \item Текущее состояние соединения - заблокирован
    \item Дальнейших действий в SMTP контроллере по данному соединению произвести невозможно.
\end{itemize} 
Если по текущемо соединению все задания на текущий момент были завершены, то активное соединение удаляется из списка. 
Стоит отметить что, для того чтобы новые заявки не накапливались во время ожидания активных соединений, решено использовать таймер. Таким образом, все новые заявки будут распределяться по своим соединениям даже когда они не готовы.
Ранее, отмечалось, что воркер управляется главным потоком через сигнал. Он используется как для оповещения новых заданий, так и для завершения работы. Принцип \textit{"Изящного завершения"} должен учитывать состояния соединений воркера. Поэтому заверешние воркера заключается в уменьшении текущих задач. Для всех соединений задания, которые необходимо будет выполнить(не текущее) удаляется из списка заданий, а само письмо переноситься в начальную директорию (/new) пользователя. В случае, если соединение еще не было корректно установлено (для данного соединения еще не было приветствия от SMTP сервера), тогда первое задание тоже удаляется, файл переноситься, а соединение закрывается и удаляется. Текущие же задания, если стадия "приветствия" прошла успешно обрабатываются до конца. После обработки всех оставшихся соединений, воркер освобождает занимаемые им ресурсы и сообщает о завершении работы.

\subsection{Обработка новых писем}
Для отправки писем, необходимо найти письма в maildir и отправить их воркерам на выполнение. Функцию поиска писем выполняет главный поток. После инициализации всех необходимых структур и данных главный поток проверяет maildir на наличие новых писем. Сначала формируется список пользователей SMTP клиента. После, в каждой директории из списка проверяется директория \textbf{new} на наличие новых писем. Если в данном каталоге есть файлы, необходимо выделить информацию о адресате письма. Адресат письма получается из поля \textbf{To} письма. На его основе формируется домен, ответственный за прием писем пользователей. 
Найденное письмо перемещается в директорию \textbf{tmp} и для него формируется заявка на отправку. В заявке указан ответственный домен и путь к письму. После производится поиск подходящего воркера и задание на оптравку делегируется. Когда список файлов на отправку освобождается главный поток ожидает 30 секунд и повторяет поиск заново. Для корректного распределения используется метрика загруженности воркеров. Она отображает сколько задач уже было делегировано воркеру.

\subsection{Словарь}
Для контроля распределения заявок между воркерами, а так же отправки писем через одну соединение, хоть это и не обязательно, решено использовать словарь. В данном словаре хранится информация о распределении доменов между воркерами. Во время поиска писем, главный поток узнает ответственный домен и смотрит свой словарь доменов. Если в нем нет воркера, который уже работает с данным доменом, то выбирается наимение загруженный воркер. В случае если есть воркер, то новое письмо делегируется ему.
Рабочий процесс также взаимодействует с данным словарем. Когда список заданий для какого-либо определенного домена закончился, соединение переходит в режим "завершения" отправки писем. В данный момент и воркер удаляет запись в словаре для данного домена. Таким образом, система старается(не гарантирует) отправить все письма адресованные одному домену через одно активное соединение.

\subsection{Рабочий поток}
Каждый рабочий поток обладает записью с необходимой информацией о себе. Данная информация передается ему при создании. С помощью общей с главным потоком блоком информации, воркер может получать новые задания узнавать о текущем состоянии работы программы. В данном блоке целесообразно хранить следующую информацию:
\begin{itemize}
    \item ссылку на очередь новых заданий
    \item личный идентификатор (удобно для логгирования)
    \item состояние работы
    \item количество заданий
\end{itemize}
Доступ к очереди заданий рабочего процесса имею два потока: главный и сам рабочий поток. Для исключения коллизий, потери данных необходимо использовать объект синхронизации. В качестве такого объекта синхронизации является семафор. 
Для корректной работы, каждый воркер создает во время подготовки структуру, с помощью которой будет осуществляться контроль соединений и их состояний. Разграничение между состояниями соединений необходимо учитывать во время передачи данных. Для этого в данной структуре содержатся множества ожидающих на запись и ожидающих на чтение соединений. 

Параметр состояния работы, указывает рабочему процессу на необходимость корректного и быстрого завершения работы. В связи с этим, рабочий процесс, узнав о необходимости завершения, убирает все задания, которые еще не выполнялись у каждого соединения. Также изменяется время ожидания активизации соединений. Это необходимость обусловлена неблокируемостью сокетов, из-за чего у соединения нет как такого \textit{timeout} на получение или отправку. Стоит отметить, что у каждого соединения текущее задание остается для корректного завершения обмена информацией с серверами.

Каждое активное соединение обрабатывается с помощью SMTP контроллера

\subsection{Активное соедиение}
Каждое соедиенние должно быть однозначно определено. Для контроля соединений целесообразно описать соединение следующим образом
\begin{itemize}
    \item идентификатор соединения
    \item домен сервера
    \item адрес сервера
    \item текущее состояние соединения
    \item предыдущее состояние соединения
    \item количество попыток отправки одного письма
    \item список писем
    \item данные текущего письма
\end{itemize}

Во время подготовки к соединению необходимо разрешить адрес сервера. Для этого для указанного домена необходимо запросить MX запись. Из этой записи получается доменное имя самого SMTP сервера, с которым необходимо обмениваться данными. Однако, для корректного обмена необходимо узнать его IP адрес в сети. Для этого полученной записи запрашивается список IP адресов и выбирается первый успешно обработанный. 
Для оптимальной обработки писем, целесообразно хранить в памяти только служебную информацию, которая необходима для передачи письма. Для этих целей выделена отдельный блок "данные письма". В данной блоке хранится адресат и адресант письма. Это позволяет сократить время на открытия файл и взаимодействия с ним во время установленного соединения

\subsection{SMTP контроллер}
SMTP контроллер отвечает за корректность общения с серверами. Для контроля обмена информацией данный контроллер ослеживает состояния общения и ведет их учет. Таким образом исключается возможность непредвиденных переходов, отправки некорректного сообщения, а так же исключается очередность отправки/получения сообщений между SMTP клиентом и SMTP сервером. Состояния соединений и переходы между ними отображены на Рис. ~\ref{fig:smtp-client-states}

\begin{figure}
    \centering
    \includegraphics[height=\textheight]{static/ClientDiagram_Final.jpg}
    \caption{Конечный автомат cостояний соединений SMTP клиента}
    \label{fig:smtp-client-states}
\end{figure}

Стоит отметить, что во при переходе к завершению обмена данными по данному соединение именно SMTP контроллер удаляет запись из \textit{словаря}. Это необходимо для исключения появления писем по закрывающемуся соединению. Таким образом, главный поток не будет делегировать письма воркеру, который завершает процесс передачи для данного домена и выберет наиболее свободного воркера.
Отправка команд протокола SMTP сопровождается верификацией ответов от сервера. Каждый ответ сервера проверяется на соблюдение регламента передачи. Так, во время подключения к SMTP серверу и получения сообщения от сервера с доменным именем за который он отвечает, происходит верификация статуса ответа и самого домена. В случае нарушения соглашения: некорректный ответ или указанный в сообщение домен не совпадает с указанным в соединение, возникает ошибка, которая разрешается закрытием соединения и освобождению ресурсов.

\subsection{Синтаксис поддерживаемых команд протокола}
В данном разделе приведены поддерживаемые клиентом команды протокола SMTP.

\begin{itemize}
    \item \textbf{EHLO}: {\it EHLO [w+]+\/}
    \item \textbf{MAIL}: {\it MAIL FROM: <[\textbackslash w]+@[\textbackslash w]+\.[\textbackslash w]+>\/}
    \item \textbf{RCPT}: {\it RCPT To:<[\textbackslash w]+@[\textbackslash w]+\.[\textbackslash w]+>\/}
    \item \textbf{DATA}: {\it DATA\/}
    \item \textbf{RSET}: {\it RSET\/}
    \item \textbf{QUIT}: {\it QUIT\/}
\end{itemize}

% \begin{itemize}
%     \item EHLO <my_domain><CRLF>
%     \item MAIL FROM:< <sender> > <CRLF>
%     \item RCPT To:< <destination> > <CRLF>
%     \item DATA <CRLF> 
%     \item QUIT <CRLF>
%     \item RSET <CRLF>
% \end{itemize}

\chapter{Технологический раздел}

\section{Сервер}

\section{Клиент}

\subsection{Графы вызова функций}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{include/ccflow01_dot.pdf}
    \caption{Граф вызовов, основные функции}
    \label{fig:ccflow01}
\end{figure}
    
\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{include/ccflow02_dot.pdf}
    \caption{Граф вызовов, взаимодействие с сервером}
    \label{fig:ccflow02}
\end{figure}

\subsection{Основные данные}

Стркутура рабочего процесса
\begin{verbatim}
    struct worker
    {
        pthread_t thread;
        sem_t lock;
        struct worker_task *tasks;
        int workerId;
        int count_task;
        bool worked;
    };
\end{verbatim}

Структура соединения
\begin{verbatim}
    struct FileDesc
    {
        int id;
        char *domain;
        char *mx_record;
        struct sockaddr_in addr;
        int current_state;
        int prev_state;
        int attempt;
        struct worker_task *task_pool;
        struct letter_info meta_data;
    };
\end{verbatim} 

\subsection{Тестирование}

\begin{verbatim}
    CUnit - A unit testing framework for C - Version 2.1-3
     http://cunit.sourceforge.net/


    Suite: suite_test
    Test: domain_is_NULL ...passed
    Test: bad_domain ...passed
    Test: connection_is_blocked ...passed
    Test: greeting_bad_graph_state ...passed
    Test: in_greeting_not_correct_domain ...passed
    Test: send_ehlo_and_correct_result ...passed
    Test: send_ehlo_and_change_state_on_error ...passed

    Run Summary:    Type  Total    Ran Passed Failed Inactive
                suites      1      1    n/a      0        0
                tests      7      7      7      0        0
                asserts     24     24     24      0      n/a

    Elapsed time =    0.004 seconds
\end{verbatim}

\subsection{Valgrind}

\begin{verbatim}
    ==24216== LEAK SUMMARY:
    ==24216==    definitely lost: 326 bytes in 6 blocks
    ==24216==    indirectly lost: 1,056 bytes in 4 blocks
    ==24216==      possibly lost: 272 bytes in 1 blocks
    ==24216==    still reachable: 1,638 bytes in 4 blocks
    ==24216==         suppressed: 0 bytes in 0 blocks
    ==24216== Reachable blocks (those to which a pointer was found) are not shown.
    ==24216== To see them, rerun with: --leak-check=full --show-leak-kinds=all
    ==24216== 
    ==24216== For counts of detected and suppressed errors, rerun with: -v
    ==24216== Use --track-origins=yes to see where uninitialised values come from
    ==24216== ERROR SUMMARY: 33 errors from 21 contexts (suppressed: 0 from 0)
\end{verbatim}

\subsection{Пример работы относительно сервер}

\begin{verbatim}
    11 Jan 2019 00:07:51 DEBUG org.subethamail.smtp.server.Session - Server: 220 samsung-np530u4c ESMTP SubEthaSMTP null
    11 Jan 2019 00:07:51 DEBUG org.subethamail.smtp.server.Session - Client: EHLO samsung-np530u4c
    11 Jan 2019 00:07:51 DEBUG org.subethamail.smtp.server.Session - Server: 250-samsung-np530u4c
    250-8BITMIME
    250-AUTH LOGIN
    250 Ok
    11 Jan 2019 00:07:58 DEBUG org.subethamail.smtp.server.Session - Client: MAIL FROM:<mail.ru>
    11 Jan 2019 00:07:58 DEBUG org.subethamail.smtp.server.Session - Server: 250 Ok
    11 Jan 2019 00:07:58 DEBUG org.subethamail.smtp.server.Session - Client: RCPT To: <samsung-np530u4c>
    11 Jan 2019 00:07:58 DEBUG org.subethamail.smtp.server.Session - Server: 250 Ok
    11 Jan 2019 00:08:01 DEBUG org.subethamail.smtp.server.Session - Client: DATA
    11 Jan 2019 00:08:01 DEBUG org.subethamail.smtp.server.Session - Server: 354 End data with <CR><LF>.<CR><LF>
    11 Jan 2019 00:08:02 DEBUG org.subethamail.smtp.server.Session - Server: 250 Ok
    11 Jan 2019 00:08:07 DEBUG org.subethamail.smtp.server.Session - Client: MAIL FROM:<mail.ru>
    11 Jan 2019 00:08:07 DEBUG org.subethamail.smtp.server.Session - Server: 250 Ok
    11 Jan 2019 00:08:07 DEBUG org.subethamail.smtp.server.Session - Client: RCPT To: <samsung-np530u4c>
    11 Jan 2019 00:08:07 DEBUG org.subethamail.smtp.server.Session - Server: 250 Ok
    11 Jan 2019 00:08:08 DEBUG org.subethamail.smtp.server.Session - Client: DATA
    11 Jan 2019 00:08:08 DEBUG org.subethamail.smtp.server.Session - Server: 354 End data with <CR><LF>.<CR><LF>
    11 Jan 2019 00:08:10 DEBUG org.subethamail.smtp.server.Session - Server: 250 Ok
    11 Jan 2019 00:08:17 DEBUG org.subethamail.smtp.server.Session - Client: QUIT
    11 Jan 2019 00:08:17 DEBUG org.subethamail.smtp.server.Session - Server: 221 Bye
\end{verbatim}

% Нужно отметьть, что символ <<\_>> необходимо оформлять как <<\textbackslash\_>>.

\section{Сборка программы}

Сборка программы описана в файле \textit{Makefile} системы сборки \textit{make}. Рис.~\ref{fig:make} нагенерили самодельные \textit{makesimple} и \textit{makefile2dot}, а также \textit{dot2tex} и \textit{dot}.

\begin{figure}
\centering
% \includegraphics[width=\textwidth]{include/Makefile_1_dot.pdf}
\caption{Сборка программы}
\label{fig:make}
\end{figure}

Отмечу, что за исключения целей типа \textit{all}, \textit{install}, \textit{clean}, \textit{tests}, все имена целей в файле систем сборки \textit{make} обычно совпадают с именами файлов (такой вот низкоуровневый инструмент). То есть вместо цели \textit{lexer} следует использовать цель \textit{src/lexer.c}.

\section{Основные функции программы}

Весь это раздел сгеренерировал doxygen из части комментированных исходников программы. В файле конфигурации \textbf{doxyggen.cfg} был отключён параметр \textbf{HAVE\_DOT}, поскольку для рисования графов вызовов используется \textit{cflow}.

% \input{include/files}

% \input{include/server-state_8h.tex}
% \input{include/server-state_8c.tex}
% \input{include/server-re_8h.tex}
% \input{include/server-cmd_8h.tex}
% \input{include/server-cmd_8c.tex}
% \input{include/server-parse_8h.tex}
% \input{include/server-parse_8c.tex}
% \input{include/server-run_8h.tex}
% \input{include/server-run_8c.tex}
% \input{include/server_8c.tex}


\section{Графы вызова функций}

Поскольку функций много, графы вызовов разбиты на два рисунка. На рис.~\ref{fig:ccflow01} показаны основные функции, на рис.~\ref{fig:scflow01}~-- функции обработки команд. Файл \textbf{cflow.ignore} содержит список функций (точнее, шабловнов поиска), использыемых программой \textit{grep} для удаления малоинтересных стандартных функций\footnote{Функции по работе с сокетами, ipc и привилегиями к малоинтересным ни в коем случае не относятся.}.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{include/scflow01_dot.pdf}
\caption{Граф вызовов, функции обработки команд}
\label{fig:scflow01}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{include/scflow02_dot.pdf}
\caption{Граф вызовов, функции обработки команд}
\label{fig:scflow01}
\end{figure}

\addcontentsline{toc}{chapter}{Выводы}
\chapter*{Выводы}

Что вы сделали и поняли.


\end{document}
